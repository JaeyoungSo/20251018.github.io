<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>기억력 카드 게임</title>
    <style>
        /* CSS 부분은 변경 없음. 이전 응답의 CSS를 그대로 사용합니다. */
        body {
            margin: 0;
            overflow: hidden; /* 스크롤 방지 */
            display: flex; 
            flex-direction: column; 
            justify-content: flex-start; /* 상단 정렬 */
            align-items: center; /* 가로 중앙 정렬 */
            min-height: 100vh;
            background-color: #f0f8ff; 
            font-family: 'Arial', sans-serif;
            color: #333;
            user-select: none; 
            -webkit-user-select: none; 
            -moz-user-select: none; 
            -ms-user-select: none; 
            touch-action: manipulation; 
        }

        #game-container {
            position: relative; /* 뷰포트 기준 absolute 대신 상대 위치로 변경 */
            margin-top: 20px; /* 상단에서 약간 여백을 줘서 붙도록 합니다. 필요에 따라 조절하세요. */
            
            width: min(90vw, 600px); 
            padding: 10px;
            background-color: #e6f7ff;
            border: 2px solid #aaddff;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            align-items: center;
            height: var(--game-container-height); /* JS에서 계산된 높이 고정 */
            transition: height 0.3s ease-out; 
            box-sizing: border-box; /* padding 포함 너비 계산 */
        }

        #game-info {
            width: 100%;
            display: flex;
            justify-content: space-around;
            margin-bottom: 15px;
            font-size: 1.1em;
            font-weight: bold;
            color: #555;
            position: relative; 
            z-index: 101; /* 셔플 카드(z-index: 100)보다 높게 설정 */
            background-color: #e6f7ff; /* game-container와 동일한 배경색으로 카드 비침 방지 */
            padding-bottom: 5px; 
        }

        #card-grid {
            display: grid; 
            grid-template-columns: repeat(4, 1fr); 
            grid-template-rows: repeat(4, 1fr); 
            gap: 10px; 
            width: min(85vw, 550px); 
            aspect-ratio: 1 / 1; /* 가로세로 비율 1:1 유지 */
            flex-grow: 1; /* 남은 공간을 차지하도록 */
        }

        .card {
            position: relative; 
            width: 100%;
            height: 100%;
            transform-style: preserve-3d; 
            transition: transform 0.6s; 
            cursor: pointer;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            transition: transform 0.6s, left 0.5s ease-in-out, top 0.5s ease-in-out, z-index 0.3s; 
        }

        .card.flipped {
            transform: rotateY(180deg);
        }

        .card-face {
            position: absolute;
            width: 100%;
            height: 100%;
            backface-visibility: hidden; 
            border-radius: 8px;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            font-weight: bold;
            color: white;
            overflow: hidden; 
        }

        .card-front {
            background-color: #fff; 
            transform: rotateY(180deg); 
        }

        .card-front img {
            width: 100%;
            height: 100%;
            object-fit: cover; 
            border-radius: 8px;
        }

        .card-back {
            background-color: #87ceeb; 
            border: 2px solid #4682b4;
        }
        .card-back::after {
            content: '❤️'; 
            font-size: 2em; /* 카드 크기에 맞춰 자연스럽게 */
        }

        .card.shuffling {
            position: absolute !important; 
            z-index: 100; 
            will-change: left, top, transform; /* 애니메이션 성능 최적화 */
        }

        #start-screen, #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 200;
        }
        #start-screen h2, #game-over-screen h2 {
            margin-bottom: 20px;
            font-size: 2em;
        }
        #start-screen button, #game-over-screen button {
            padding: 12px 25px;
            font-size: 1.3em;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
        }
        #start-screen button:hover, #game-over-screen button:hover {
            background-color: #45a049;
        }

        /* 랭크보드 테이블 CSS 추가 */
        #leaderboard-display table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
        }
        #leaderboard-display th, #leaderboard-display td {
            border: 1px solid #eee;
            padding: 8px;
            text-align: center;
        }
        #leaderboard-display th {
            background-color: #f2f2f2;
            font-weight: bold;
            color: #333; /* 텍스트 색상 추가 */
        }
        #leaderboard-display tr:nth-child(even) {
            background-color: #f9f9f9;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="game-info">
            <span>스테이지: <span id="stage-display">1</span></span>
            <span>시간: <span id="time-display">--</span></span>
            <span>점수: <span id="score-display">0</span></span>
        </div>
        <div id="card-grid">
            </div>
    </div>

    <div id="start-screen">
        <h2>기억력 카드 게임</h2>
        <p>사진 짝을 맞춰 기억력을 테스트해보세요!</p>
        <button id="start-button">게임 시작</button>
    </div>

    <div id="game-over-screen" style="display: none;">
        <h2>게임 오버!</h2>
        <p>최종 점수: <span id="final-score">0</span></p>
        <button id="restart-button">다시 시작</button>
        
        <hr style="width: 80%; margin: 20px auto;">
        <h3>랭크보드</h3>
        <div id="leaderboard-display" style="
            background-color: #fff; 
            padding: 10px; 
            border-radius: 5px; 
            max-height: 200px; 
            overflow-y: auto; 
            width: 80%;
            margin: 0 auto;
            color: #333;
            font-size: 0.9em;
        ">
            <p>랭크보드를 불러오는 중...</p>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const cardGrid = document.getElementById('card-grid');
            const gameContainer = document.getElementById('game-container'); 
            const stageDisplay = document.getElementById('stage-display');
            const timeDisplay = document.getElementById('time-display');
            const scoreDisplay = document.getElementById('score-display');
            const startScreen = document.getElementById('start-screen');
            const startButton = document.getElementById('start-button');
            const gameOverScreen = document.getElementById('game-over-screen');
            const restartButton = document.getElementById('restart-button');
            const finalScoreDisplay = document.getElementById('final-score');
            const leaderboardDisplay = document.getElementById('leaderboard-display'); // 랭크보드 요소 추가

            const NUM_PAIRS = 8; 
            const GRID_SIZE = 4; 
            const CARD_COUNT = NUM_PAIRS * 2; 

            // Apps Script 웹 앱 URL (랭크보드 API 엔드포인트)
            const LEADERBOARD_API_URL = '여기에_배포한_Apps_Script_웹_앱_URL을_붙여넣으세요';

            let imagePaths = [
                '../assets/img/game1.jpg', 
                '../assets/img/game2.jpg', 
                '../assets/img/game3.jpg', 
                '../assets/img/game4.jpg', 
                '../assets/img/game5.jpg', 
                '../assets/img/game6.jpg', 
                '../assets/img/game7.jpg', 
                '../assets/img/game8.jpg', 
            ];
            // 이미지 경로 배열을 짝수개로 만듦 (각 이미지를 두 번씩)
            imagePaths = [...imagePaths, ...imagePaths];

            let cards = []; 
            let flippedCards = []; 
            let matchedPairs = 0; 
            let allowFlip = false; 

            let gameStage = 1;
            let gameScore = 0;
            let timeLeft = 0;
            let timerInterval;

            let cardWidth = 0; 
            let cardHeight = 0;
            let gameContainerHeight = 0; 

            // --- 게임 초기화 및 시작 ---
            function initializeGame() {
                clearInterval(timerInterval);
                cardGrid.innerHTML = ''; // 기존 카드 DOM 모두 제거
                cards = []; // 카드 배열 초기화
                flippedCards = [];
                matchedPairs = 0;
                gameStage = 1;
                gameScore = 0;
                allowFlip = false;
                
                updateUI();
                createCards(); // 새롭게 카드 생성
                positionCardsInitially(); // 초기 배치 위치 및 크기 계산

                gameOverScreen.style.display = 'none';
                startScreen.style.display = 'flex';
                // 게임 시작 화면에 랭크보드 표시 (선택 사항)
                // displayLeaderboard(); 
            }

            function startGame() {
                startScreen.style.display = 'none';
                resetStage();
            }

            function resetStage() {
                clearInterval(timerInterval);
                timeLeft = calculateTimeLimit(gameStage);
                updateUI();
                
                // 카드 상태 초기화 (뒤집힌 상태, 매칭 상태 제거)
                cards.forEach(card => {
                    card.element.classList.remove('flipped', 'matched');
                    card.isFlipped = false;
                    card.isMatched = false;
                    card.element.style.pointerEvents = 'none'; 
                });

                // 카드를 섞기 위해 잠시 뒤집어서 보여줌
                setTimeout(() => {
                    showAllCardsTemporarily(); 
                }, 500); 
            }

            function calculateTimeLimit(stage) {
                return Math.max(10, 35 - (stage - 1) * 5); 
            }

            function startTimer() {
                clearInterval(timerInterval);
                timerInterval = setInterval(() => {
                    timeLeft--;
                    timeDisplay.textContent = timeLeft;
                    if (timeLeft <= 0) {
                        clearInterval(timerInterval);
                        endGame(false);
                    }
                }, 1000);
            }

            // --- 카드 생성 및 초기 배치 ---
            function createCards() {
                let cardValues = [];
                for (let i = 0; i < NUM_PAIRS; i++) {
                    cardValues.push(i, i);
                }
                shuffleArray(cardValues); // 카드 값 자체를 섞음

                cardGrid.innerHTML = ''; // 카드 그리드 비우기 (새로운 카드를 위해)
                cards = []; // 기존 카드 배열 완전히 비우기

                for (let i = 0; i < CARD_COUNT; i++) {
                    const cardElement = document.createElement('div');
                    cardElement.classList.add('card');

                    const cardFront = document.createElement('div');
                    cardFront.classList.add('card-face', 'card-front');
                    const img = document.createElement('img');
                    img.src = imagePaths[cardValues[i]]; 
                    img.alt = `Card ${cardValues[i]}`;
                    cardFront.appendChild(img);

                    const cardBack = document.createElement('div');
                    cardBack.classList.add('card-face', 'card-back');

                    cardElement.appendChild(cardFront);
                    cardElement.appendChild(cardBack);

                    // 클릭 이벤트 리스너는 카드 생성 시점에 추가
                    cardElement.addEventListener('click', () => handleCardClick(cardElement, cardValues[i]));
                    
                    cardGrid.appendChild(cardElement);

                    cards.push({
                        element: cardElement,
                        value: cardValues[i],
                        isFlipped: false,
                        isMatched: false,
                        initialGridIndex: i, // 초기 생성 시 그리드 인덱스
                        currentX: 0, 
                        currentY: 0  
                    });
                }
            }

            // 카드가 그리드에 배치된 후, 각 카드의 정확한 픽셀 위치와 크기를 저장
            // 이 함수는 DOM 변화가 일어날 때마다 호출되어 정확한 위치를 갱신해야 합니다.
            function positionCardsInitially() {
                // DOM에 카드가 올바른 그리드 순서로 있는지 확인 (선택 사항, createCards에서 이미 처리)
                // cards.sort((a, b) => a.initialGridIndex - b.initialGridIndex); 
                // cardGrid.innerHTML = ''; 
                // cards.forEach(card => {
                //     card.element.style.transform = ''; 
                //     card.element.classList.remove('shuffling');
                //     card.element.style.left = '';
                //     card.element.style.top = '';
                //     card.element.style.width = ''; 
                //     card.element.style.height = ''; 
                //     card.element.style.position = ''; 
                //     card.element.style.zIndex = '';
                //     cardGrid.appendChild(card.element);
                // });

                requestAnimationFrame(() => { 
                    requestAnimationFrame(() => { 
                        const firstCardRect = cards[0].element.getBoundingClientRect();
                        cardWidth = firstCardRect.width;
                        cardHeight = firstCardRect.height;

                        gameContainerHeight = gameContainer.offsetHeight; 

                        document.documentElement.style.setProperty('--card-width', `${cardWidth}px`);
                        document.documentElement.style.setProperty('--card-height', `${cardHeight}px`);
                        document.documentElement.style.setProperty('--game-container-height', `${gameContainerHeight}px`);

                        const gameContainerRect = gameContainer.getBoundingClientRect();

                        cards.forEach(card => {
                            const rect = card.element.getBoundingClientRect();
                            card.currentX = rect.left - gameContainerRect.left;
                            card.currentY = rect.top - gameContainerRect.top;
                        });

                        console.log("Card dimensions:", cardWidth, cardHeight);
                        console.log("Game Container Height:", gameContainerHeight);
                        console.log("Card positions updated:", cards.map(c => ({ id: c.value, x: c.currentX, y: c.currentY })));
                    });
                });
            }

            // 배열 섞기 함수 (Fisher-Yates shuffle)
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
            }

            // --- 게임 로직 ---
            function showAllCardsTemporarily() {
                cards.forEach(card => {
                    if (!card.isMatched) { 
                        card.element.classList.add('flipped');
                        card.isFlipped = true;
                    }
                });

                const revealTime = 3000; 
                setTimeout(() => {
                    // 셔플 애니메이션을 위해 카드들을 absolute 포지션으로 변경
                    cardGrid.style.display = 'block'; // 그리드 레이아웃 대신 블록으로 전환

                    cards.forEach(card => {
                        if (!card.isMatched) {
                            card.element.classList.add('shuffling'); 
                            card.element.style.left = `${card.currentX}px`;
                            card.element.style.top = `${card.currentY}px`;
                            card.element.style.width = `${cardWidth}px`;
                            card.element.style.height = `${cardHeight}px`;
                            card.element.style.transform = 'none'; 
                        }
                    });

                    startShuffleAnimation(gameStage, () => {
                        // 셔플 애니메이션이 끝나면 DOM에서 카드들을 실제 순서에 맞게 재배치
                        cardGrid.innerHTML = ''; // 기존 카드 DOM 모두 제거
                        // cards 배열은 이미 셔플 로직에서 순서가 바뀌어 있음
                        cards.forEach(card => {
                            card.element.classList.remove('flipped', 'shuffling'); 
                            card.isFlipped = false;
                            card.element.style.width = ''; 
                            card.element.style.height = ''; 
                            card.element.style.left = ''; // left, top 스타일 제거하여 그리드 레이아웃 적용
                            card.element.style.top = ''; 
                            cardGrid.appendChild(card.element); // DOM에 새로운 순서로 추가
                        });
                        cardGrid.style.display = 'grid'; // 그리드 레이아웃 복원
                        
                        // 재배치 후 새로운 위치 값 다시 계산 및 저장
                        positionCardsInitially(); 

                        setTimeout(() => {
                            cards.forEach(card => {
                                if (!card.isMatched) {
                                    card.element.style.pointerEvents = 'auto'; 
                                }
                            });
                            allowFlip = true; 
                            startTimer(); 
                        }, 600); 
                    });
                }, revealTime);
            }

            // --- 셔플 애니메이션 (두 카드 위치 교환) ---
            async function startShuffleAnimation(stage, callback) {
                const shuffleCount = 3 + (stage - 1) * 2; 
                const shuffleDuration = 500; // 애니메이션 시간 단축

                for (let i = 0; i < shuffleCount; i++) {
                    const availableCards = cards.filter(card => !card.isMatched);
                    if (availableCards.length < 2) break; 

                    const idx1 = Math.floor(Math.random() * availableCards.length);
                    let idx2 = Math.floor(Math.random() * availableCards.length);
                    while (idx1 === idx2) {
                        idx2 = Math.floor(Math.random() * availableCards.length);
                    }

                    const card1 = availableCards[idx1];
                    const card2 = availableCards[idx2];

                    // 시각적으로 위치 교환 애니메이션 실행
                    await performTwoCardShuffleAnimation(card1, card2, shuffleDuration);
                    
                    // console.log(`셔플 ${i+1}/${shuffleCount}: 카드 ${card1.value}와 카드 ${card2.value} 교환`);
                }
                callback();
            }

            // 두 카드 위치 교환 애니메이션
            function performTwoCardShuffleAnimation(cardA, cardB, duration) {
                return new Promise(resolve => {
                    const xA = cardA.currentX;
                    const yA = cardA.currentY;
                    const xB = cardB.currentX;
                    const yB = cardB.currentY;

                    // 시각적으로 위치 변경
                    cardA.element.style.left = `${xB}px`;
                    cardA.element.style.top = `${yB}px`;
                    cardB.element.style.left = `${xA}px`;
                    cardB.element.style.top = `${yA}px`;

                    cardA.element.classList.add('shuffling');
                    cardB.element.classList.add('shuffling');

                    setTimeout(() => {
                        // 중요: 애니메이션이 끝난 후, 카드 객체의 실제 위치와 순서를 업데이트합니다.
                        // cardA와 cardB 객체 자체의 currentX, currentY를 교환
                        [cardA.currentX, cardB.currentX] = [xB, xA];
                        [cardA.currentY, cardB.currentY] = [yB, yA];

                        // 중요: cards 배열 내에서 cardA와 cardB의 위치를 실제로 교환
                        // 이는 다음 셔플이나 DOM 재구성에 영향을 미칩니다.
                        const indexA = cards.indexOf(cardA);
                        const indexB = cards.indexOf(cardB);
                        [cards[indexA], cards[indexB]] = [cards[indexB], cards[indexA]];

                        // 셔플 클래스 제거 (다음 셔플을 위해)
                        cardA.element.classList.remove('shuffling');
                        cardB.element.classList.remove('shuffling');

                        resolve(); 
                    }, duration);
                });
            }

            // 카드 뒤집기
            function handleCardClick(cardElement, value) {
                if (!allowFlip || flippedCards.length >= 2 || cardElement.classList.contains('flipped') || cardElement.classList.contains('matched')) {
                    return; 
                }

                const card = cards.find(c => c.element === cardElement);
                if (!card) return; 

                card.element.classList.add('flipped');
                card.isFlipped = true;
                flippedCards.push(card);

                if (flippedCards.length === 2) {
                    allowFlip = false; 
                    checkMatch();
                }
            }

            // 짝 맞추기 확인
            function checkMatch() {
                const [card1, card2] = flippedCards;

                if (card1.value === card2.value) {
                    gameScore += 100;
                    card1.element.classList.add('matched');
                    card2.element.classList.add('matched');
                    card1.isMatched = true;
                    card2.isMatched = true;
                    matchedPairs++;
                    updateUI();

                    setTimeout(() => {
                        flippedCards = [];
                        allowFlip = true;
                        if (matchedPairs === NUM_PAIRS) {
                            setTimeout(() => {
                                nextStage();
                            }, 500); 
                        }
                    }, 800); 
                } else {
                    gameScore = Math.max(0, gameScore - 50);
                    updateUI();
                    setTimeout(() => {
                        card1.element.classList.remove('flipped');
                        card2.element.classList.remove('flipped');
                        card1.isFlipped = false;
                        card2.isFlipped = false;
                        flippedCards = [];
                        allowFlip = true;
                    }, 1000); 
                }
            }

            function nextStage() {
                clearInterval(timerInterval);
                gameStage++;
                matchedPairs = 0;
                resetStage();
            }

            function endGame(isWin) {
                clearInterval(timerInterval);
                allowFlip = false;
                finalScoreDisplay.textContent = gameScore;
                gameOverScreen.style.display = 'flex';

                // --- 랭크보드 점수 전송 기능 추가 ---
                const playerName = prompt("게임 오버! 당신의 이름을 입력하세요 (최대 10자):", "익명");
                const trimmedName = playerName ? playerName.substring(0, 10) : "익명";

                sendScoreToLeaderboard(trimmedName, gameScore, gameStage);
                // --- 랭크보드 점수 전송 기능 추가 끝 ---
            }

            function updateUI() {
                stageDisplay.textContent = gameStage;
                timeDisplay.textContent = timeLeft;
                scoreDisplay.textContent = gameScore;
            }

            // --- 랭크보드 관련 함수 (이전 응답에서 제공된 코드) ---
            async function sendScoreToLeaderboard(name, score, stage) {
                try {
                    const response = await fetch(LEADERBOARD_API_URL, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'text/plain;charset=utf-8', 
                        },
                        body: JSON.stringify({ name: name, score: score, stage: stage })
                    });
                    const result = await response.json();
                    if (result.status === 'success') {
                        console.log('점수가 랭크보드에 성공적으로 기록되었습니다!');
                        displayLeaderboard(); 
                    } else {
                        console.error('점수 기록 실패:', result.message);
                    }
                } catch (error) {
                    console.error('랭크보드 API 호출 중 오류 발생:', error);
                }
            }

            async function displayLeaderboard() {
                leaderboardDisplay.innerHTML = '<p>랭크보드를 불러오는 중...</p>';
                try {
                    const response = await fetch(LEADERBOARD_API_URL);
                    const data = await response.json();

                    if (data && data.length > 0) {
                        let html = '<table>';
                        html += '<thead><tr><th>순위</th><th>이름</th><th>점수</th><th>스테이지</th></tr></thead>';
                        html += '<tbody>';
                        data.forEach((entry, index) => {
                            html += `<tr>
                                        <td>${index + 1}</td>
                                        <td>${entry.name}</td>
                                        <td>${entry.score}</td>
                                        <td>${entry.stage}</td>
                                     </tr>`;
                        });
                        html += '</tbody></table>';
                        leaderboardDisplay.innerHTML = html;
                    } else {
                        leaderboardDisplay.innerHTML = '<p>아직 랭크 기록이 없습니다.</p>';
                    }
                } catch (error) {
                    console.error('랭크보드 불러오기 실패:', error);
                    leaderboardDisplay.innerHTML = '<p>랭크보드를 불러오는 데 실패했습니다.</p>';
                }
            }
            // --- 랭크보드 관련 함수 끝 ---

            // --- 이벤트 리스너 ---
            startButton.addEventListener('click', startGame);
            restartButton.addEventListener('click', initializeGame);

            document.addEventListener('gesturestart', function (e) { e.preventDefault(); });
            document.addEventListener('touchstart', function (event) {
                if (event.touches.length > 1) { event.preventDefault(); }
            }, { passive: false });
            document.addEventListener('touchmove', function (event) {
                if (event.touches.length > 1) { event.preventDefault(); }
            }, { passive: false });
            document.addEventListener('touchend', function (event) {
                if (event.touches.length > 1) { event.preventDefault(); }
            });

            window.addEventListener('resize', positionCardsInitially);

            // 초기 게임 시작
            initializeGame();
        }); // DOMContentLoaded 끝
    </script>
</body>
</html>